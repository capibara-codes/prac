Q.1) Write a python program to implement to find factorial of a given Number.
	
number = int(input("Enter a non-negative integer: "))
factorial = 1
for i in range(1, number + 1):
    factorial *= i
print(f"The factorial of {number} is {factorial}.")


Q.2) Write a python program to implement Simple Chatbot.

import nltk
from nltk.chat.util import Chat, reflections

# Define pairs of patterns and responses
pairs = [
    ["hi|hello|hey", ["Hello!", "Hey there!", "Hi!"]],
    ["how are you?", ["I'm good, thanks!", "Doing well, thank you!", "I'm fine, how about you?"]],
    ["what's your name?", ["I'm a chatbot.", "You can call me Chatbot.", "I'm Chatbot!"]],
    ["quit|exit|bye", ["Goodbye!", "Bye!", "See you later!"]],
]

# Create a chatbot
chatbot = Chat(pairs, reflections)

# Start conversation
print("Welcome to the chatbot!")
print("Type 'quit' to exit.")

while True:
    user_input = input("You: ")
    response = chatbot.respond(user_input)
    print("Chatbot:", response)
    if user_input.lower() in ["quit", "exit", "bye"]:
        Break

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to find factors of a given integer.

number = int(input("Enter a non-negative integer: "))
factorial = 1
for i in range(1, number + 1):
    factorial *= i
print(f"The factorial of {number} is {factorial}.")

Q.2) Write a python program implement Breadth First Search (BFS) algorithm.

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to check whether given no is prime or Not.

n=int(input("enter a number:"))
if(n>1):
    for i in range(2,n):
        if(n%i==0):
            print(n,"is not prime")
            break
    else:
         print(n,"is prime")

Q.2) Write a python program to implement Depth First Search (DFS) algorithm.
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.
def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node,end='  ')
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)


print("Following is the Depth-First Search")
dfs(visited, graph, '5') # function calling
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to find factors of a given integer.

number = int(input("Enter a non-negative integer: "))
factorial = 1
for i in range(1, number + 1):
    factorial *= i
print(f"The factorial of {number} is {factorial}.")

Q.2) Write a python program implement Breadth First Search (BFS) algorithm.
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to check whether given no is prime or Not.

n=int(input("enter a number:"))
if(n>1):
    for i in range(2,n):
        if(n%i==0):
            print(n,"is not prime")
            break
    else:
         print(n,"is prime")

Q.2) Write a python program to implement Depth First Search (DFS) algorithm.
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.
def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node,end='  ')
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)


print("Following is the Depth-First Search")
dfs(visited, graph, '5') # function calling
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to find factors of a given integer.

number = int(input("Enter a non-negative integer: "))
factorial = 1
for i in range(1, number + 1):
    factorial *= i
print(f"The factorial of {number} is {factorial}.")

Q.2) Write a python program implement Breadth First Search (BFS) algorithm.
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to check whether given no is prime or Not.	

n=int(input("enter a number:"))
if(n>1):
    for i in range(2,n):
        if(n%i==0):
            print(n,"is not prime")
            break
    else:
         print(n,"is prime")


Q.2) Write a python program to implement Depth First Search (DFS) algorithm.
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.
def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node,end='  ')
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)


print("Following is the Depth-First Search")
dfs(visited, graph, '5') # function calling

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python Program to check whether given no is Perfect or not. 
def is_perfect(n):
 
    if n <= 0:
        return False
    
    sum_of_divisors = 0
   
    for i in range(1, n):
        # Check if i is a divisor of n
        if n % i == 0:
            sum_of_divisors += i
  
    return sum_of_divisors == n

Q.2) Write a python program to implement Depth Limited Search (DLS) algorithm.
# Driver Code
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}
def depth_limited_search(graph, start, limit):
    def dls(node, depth):
        if depth < 0 or node in visited:
            return
        print(node, end=' ')
        visited.add(node)
        for neighbor in graph.get(node, []):
            dls(neighbor, depth - 1)
    visited = set()
    dls(start, limit)

print("Depth-Limited Search:")
depth_limited_search(graph, '5', 1) # function calling

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to print Fibonacci series.

n = int(input("Enter the maximum value for Fibonacci series: "))
a, b = 0, 1
if n == 1:
    print(a)
else:
    print(a)
    if n > 1:
        print(b)
        for i in range(2, n):
            c = a + b
            a = b
            b = c
            print(c)

Q.2) Write a python program to implement Iterative Deepening DFS (IDDFS) 
algorithm.

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = {i: [] for i in range(vertices)}

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dls(self, src, target, limit):
        if src == target:
            return True
        if limit <= 0:
            return False
        for neighbor in self.graph[src]:
            if self.dls(neighbor, target, limit - 1):
                return True
        return False

    def iddfs(self, src, target, max_depth):
        for depth in range(max_depth + 1):
            if self.dls(src, target, depth):
                return True
        return False


if __name__ == "__main__":
    g = Graph(7)
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 3)
    g.add_edge(1, 4)
    g.add_edge(2, 5)
    g.add_edge(2, 6)

    src = 0
    target = 6
    max_depth = 3

    if g.iddfs(src, target, max_depth):
        print("Target is reachable within max depth")
    else:
        print("Target is not reachable within max depth")

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to display the calendar of the given month and Year.

# Get the month and year from the user
year = int(input("Enter year (e.g., 2024): "))
month = int(input("Enter month (1-12): "))
# Display the calendar for the specified month and year
print(calendar.month(year, month))

Q.2) Write a python program to implement Uniform Cost Search (UCS) algorithm.
from heapq import heappush, heappop
from collections import defaultdict

def uniform_cost_search(start, goal, neighbors, cost):
    frontier = []
    heappush(frontier, (0, start))
    
    came_from = {}
    g_score = defaultdict(lambda: float('inf'))
    g_score[start] = 0
    
    while frontier:
        current_cost, current = heappop(frontier)
        
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            path.reverse()
            return path, g_score[goal]
        
        if current_cost > g_score[current]:
            continue
            
        for next_state in neighbors(current):
            new_cost = current_cost + cost(current, next_state)
            
            if new_cost < g_score[next_state]:
                came_from[next_state] = current
                g_score[next_state] = new_cost
                heappush(frontier, (new_cost, next_state))
    
    return None, float('inf')

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program in python to find sum of digits of a number.
def sum_of_digits_math(n):
    if n < 0:
        n = -n
    total = 0
    while n > 0:
        total += n % 10    # get last digit
        n = n // 10        # remove last digit
    return total	

Q.2) Write a python program to implement Water Jug Problem.
from collections import defaultdict
# Define the capacities of the jugs and the target amount
jug1, jug2, aim = 4, 3, 2
# Initialize the visited dictionary
visited = defaultdict(lambda: False)
def waterJugSolver(amt1, amt2):
    # Check if we have reached the goal
    if (amt1 == aim and amt2 == 0) or (amt2 == aim and amt1 == 0):
        print(amt1, amt2)
        return True
  
    # If we have already visited this state, return False
    if visited[(amt1, amt2)]:
        return False
    
    # Mark this state as visited
    visited[(amt1, amt2)] = True
    
    # Print the current state
    print(amt1, amt2)
    
    # Recursively explore all possible actions
    return (waterJugSolver(0, amt2) or
            waterJugSolver(amt1, 0) or
            waterJugSolver(jug1, amt2) or
            waterJugSolver(amt1, jug2) or
            waterJugSolver(amt1 + min(amt2, jug1 - amt1),
                          amt2 - min(amt2, jug1 - amt1)) or
            waterJugSolver(amt1 - min(amt1, jug2 - amt2),
                          amt2 + min(amt1, jug2 - amt2)))
# Print the steps
print("Steps:")
waterJugSolver(0, 0)

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program in Python to reverse a given number.

n=int(input("enter a number:"))
temp = n
reverse = 0
while(n>0):
    digit = n % 10
    reverse = reverse*10 + digit
    n = n // 10
print(“ Reverse of number is”,reverse)
	

Q.2) Write a python program to implement Tower of Hanoi.
def tower_of_hanoi(n, src, aux, dest):
    if n == 1:
        print(f"Move disk 1 from rod {src} to rod {dest}")
        return
    tower_of_hanoi(n - 1, src, dest, aux)
    print(f"Move disk {n} from rod {src} to rod {dest}")
    tower_of_hanoi(n - 1, aux, src, dest)

if __name__ == "__main__":
    n = int(input("Enter the number of disks: "))
    tower_of_hanoi(n, 'A', 'B', 'C')
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to check whether given no is Palindrome or not.

n=int(input("enter a number:"))
temp = n
reverse = 0
while(n>0):
    digit = n % 10
    reverse = reverse*10 + digit
    n = n // 10
# Checking whether the reversed number is equal to the original number.
if(temp == reverse):
    print(temp,"is Palindrome")
else:
    print(temp,"is Not a Palindrome")


Q.2) Write a python program to implement Depth Limited Search (DLS) algorithm.
# Driver Code
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}
def depth_limited_search(graph, start, limit):
    def dls(node, depth):
        if depth < 0 or node in visited:
            return
        print(node, end=' ')
        visited.add(node)
        for neighbor in graph.get(node, []):
            dls(neighbor, depth - 1)
    visited = set()
    dls(start, limit)

print("Depth-Limited Search:")
depth_limited_search(graph, '5', 1) # function calling

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to check whether given no is Armstrong or not.
def main():
    print("=== Armstrong Number Checker ===\n")
    
    while True:
        try:
            n = input("Enter a number (or 'q' to quit): ").strip()
            
            if n.lower() in ['q', 'quit', 'exit']:
                print("Goodbye!")
                break
                
            num = int(n)
            
            # Using first method (clean & readable)
            if is_armstrong(num):
                print(f"{num} is an Armstrong number ✓")
            else:
                print(f"{num} is NOT an Armstrong number")
            
            # Optional: show the calculation
            if num >= 0:
                digits = [int(d) for d in str(num)]
                power = len(digits)
                terms = [f"{d}^{power}" for d in digits]
                calculation = " + ".join(terms)
                result = " + ".join(str(d**power) for d in digits)
                print(f"  → {calculation} = {result} = {sum(d**power for d in digits)}")
                print()
                
        except ValueError:
            if n.strip():  # avoid error message on empty input
                print("Please enter a valid integer or 'q' to quit.\n")


if __name__ == "__main__":
    main()

Q.2) Write a python program to implement Iterative Deepening DFS (IDDFS) 
algorithm.
from collections import deque

class Graph:
    def __init__(self):
        # Adjacency list representation
        self.adj = {}
    
    def add_edge(self, u, v):
        """Add undirected edge between u and v"""
        if u not in self.adj:
            self.adj[u] = []
        if v not in self.adj:
            self.adj[v] = []
        self.adj[u].append(v)
        self.adj[v].append(u)  # comment this line if you want directed graph
    
    def dfs_limited(self, start, goal, depth_limit, visited=None):
        """
        Depth-limited DFS - returns path if found within depth_limit
        Returns None if not found within the limit
        """
        if visited is None:
            visited = set()
        
        stack = [(start, [start], 0)]  # (node, path_so_far, depth)
        
        while stack:
            node, path, depth = stack.pop()  # LIFO → DFS behavior
            
            if node == goal:
                return path
            
            if depth >= depth_limit:
                continue
                
            if node in visited:
                continue
                
            visited.add(node)
            
            # Add neighbors in reverse order to maintain left-to-right DFS feel
            for neighbor in reversed(self.adj.get(node, [])):
                if neighbor not in visited:
                    stack.append((neighbor, path + [neighbor], depth + 1))
        
        return None
    
    def iddfs(self, start, goal):
        """
        Iterative Deepening DFS
        Gradually increases depth limit until goal is found or graph is exhausted
        """
        print(f"Running IDDFS from {start} → {goal}")
        depth = 0
        max_depth_tried = 0
        
        while True:
            depth += 1
            print(f"  Depth limit = {depth} ... ", end="")
            
            visited = set()  # new visited set for each depth limit
            result = self.dfs_limited(start, goal, depth, visited)
            
            if result is not None:
                print("FOUND!")
                return result
            
            print(f"not found (visited {len(visited)} nodes)")
            
            max_depth_tried = depth
            
            # Optional safety: prevent infinite loop in disconnected graph
            if depth > 50:  # arbitrary large number
                print("→ Reached maximum depth limit. Target not reachable.")
                return None
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to find GCD or HCF of two numbers.	
def main():
    print("=== GCD / HCF Finder ===\n")
    
    try:
        num1 = int(input("Enter first number: "))
        num2 = int(input("Enter second number: "))
        
        if num1 < 0 or num2 < 0:
            print("Note: Converting negative numbers to positive")
            num1 = abs(num1)
            num2 = abs(num2)
            
        if num1 == 0 and num2 == 0:
            print("GCD of 0 and 0 is undefined")
            return
            
        # Using Method 1 (Euclidean)
        result1 = gcd(num1, num2)
        
        # Using Method 2 (Recursive)
        result2 = gcd_recursive(num1, num2)
        
        # Using built-in math.gcd (Python 3.5+)
        result3 = math.gcd(num1, num2)
        
        print(f"\nGCD of {num1} and {num2} is: {result1}")
        
        # All three methods should give same result
        assert result1 == result2 == result3, "Methods gave different results!"
        
        # Bonus: Show the calculation steps (optional)
        print("\nStep-by-step Euclidean algorithm:")
        a, b = num1, num2
        while b != 0:
            print(f"{a:>6} = {b:>6} × {a//b:>2} + {a%b:>4}")
            a, b = b, a % b
        print(f"→ GCD = {a}")
        
    except ValueError:
        print("Please enter valid integers!")

if __name__ == "__main__":
    main()

Q.2) Write a python program to implement Water Jug Problem.
from collections import defaultdict
# Define the capacities of the jugs and the target amount
jug1, jug2, aim = 4, 3, 2
# Initialize the visited dictionary
visited = defaultdict(lambda: False)
def waterJugSolver(amt1, amt2):
    # Check if we have reached the goal
    if (amt1 == aim and amt2 == 0) or (amt2 == aim and amt1 == 0):
        print(amt1, amt2)
        return True
  
    # If we have already visited this state, return False
    if visited[(amt1, amt2)]:
        return False
    
    # Mark this state as visited
    visited[(amt1, amt2)] = True
    
    # Print the current state
    print(amt1, amt2)
    
    # Recursively explore all possible actions
    return (waterJugSolver(0, amt2) or
            waterJugSolver(amt1, 0) or
            waterJugSolver(jug1, amt2) or
            waterJugSolver(amt1, jug2) or
            waterJugSolver(amt1 + min(amt2, jug1 - amt1),
                          amt2 - min(amt2, jug1 - amt1)) or
            waterJugSolver(amt1 - min(amt1, jug2 - amt2),
                          amt2 + min(amt1, jug2 - amt2)))
# Print the steps
print("Steps:")
waterJugSolver(0, 0)
--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to find LCM.
print("Find LCM of two numbers")
print("------------------------")

try:
    num1 = int(input("Enter first number  : "))
    num2 = int(input("Enter second number : "))

    # Using efficient method (recommended)
    result = lcm(num1, num2)

    # You can also use the loop method:
    # result = find_lcm(num1, num2)

    print(f"\nLCM of {num1} and {num2} is: {result}")

except ValueError:
    print("Please enter valid integer numbers.")

Q.2) Write a python program to solve Tic-Tac-Toe problem.
import copy

# ------------------------------
#   BOARD REPRESENTATION
# ------------------------------
board = [' ' for _ in range(9)]  # 0 1 2
                                     # 3 4 5
                                     # 6 7 8

def print_board(b=None):
    if b is None:
        b = board
    for row in [b[i*3:(i+1)*3] for i in range(3)]:
        print(" | ".join(row))
        if row != b[6:9]:
            print("-" * 11)

def available_moves(b=None):
    if b is None:
        b = board
    return [i for i, spot in enumerate(b) if spot == ' ']

def make_move(b, pos, player):
    b[pos] = player

def undo_move(b, pos):
    b[pos] = ' '

def is_winner(b, player):
    win_patterns = [
        [0,1,2], [3,4,5], [6,7,8],  # rows
        [0,3,6], [1,4,7], [2,5,8],  # columns
        [0,4,8], [2,4,6]            # diagonals
    ]
    for combo in win_patterns:
        if all(b[i] == player for i in combo):
            return True
    return False

def is_full(b=None):
    if b is None:
        b = board
    return ' ' not in b

def terminal(b=None):
    if b is None:
        b = board
    return is_winner(b, 'X') or is_winner(b, 'O') or is_full(b)

# ------------------------------
#   MINIMAX (with alpha-beta possible, but kept simple here)
# ------------------------------
def minimax(b, is_maximizing):
    if is_winner(b, 'O'):
        return 1
    if is_winner(b, 'X'):
        return -1
    if is_full(b):
        return 0

    if is_maximizing:  # O (computer) maximizes
        best = -float('inf')
        for move in available_moves(b):
            b[move] = 'O'
            score = minimax(b, False)
            b[move] = ' '
            best = max(best, score)
        return best
    else:              # X (human) minimizes
        best = float('inf')
        for move in available_moves(b):
            b[move] = 'X'
            score = minimax(b, True)
            b[move] = ' '
            best = min(best, score)
        return best

def best_move():
    best_score = -float('inf')
    best_pos = None

    for move in available_moves():
        board[move] = 'O'
        score = minimax(board, False)
        board[move] = ' '
        if score > best_score:
            best_score = score
            best_pos = move

    return best_pos
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to check whether given Year is Leap Year.

# Get the year from the user
year = int(input("Enter a year: "))

# Check if the year is a leap year
if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    print(f"{year} is a Leap Year")
else:
    print(f"{year} is Not a Leap Year")

Q.2) Write a python program to solve 8-Puzzle problem

import heapq

class Node:
    """A node class for A* pathfinding."""
    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position
        self.g = 0 # Cost from start
        self.h = 0 # Heuristic cost to goal
        self.f = 0 # Total cost (g + h)

    def __eq__(self, other):
        return self.position == other.position

    # For use with the priority queue (heapq)
    def __lt__(self, other):
        return self.f < other.f

def astar(maze, start, end):
    """Finds the shortest path in a maze using A*."""
    # Create start and end nodes
    start_node = Node(None, start)
    end_node = Node(None, end)

    # Initialize open and closed lists
    open_list = []
    closed_list = set()

    # Add the start node to the open list
    heapq.heappush(open_list, start_node)

    # Loop until the open list is empty
    while open_list:
        # Get the current node (node with the lowest f cost)
        current_node = heapq.heappop(open_list)
        closed_list.add(current_node.position)

        # Found the goal
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current.position)
                current = current.parent
            return path[::-1] # Return reversed path

        # Explore neighbors (up, down, left, right)
        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        for new_position in neighbors:
            # Get neighbor node position
            node_position = (current_node.position[0] + new_position[0], 
                             current_node.position[1] + new_position[1])

            # Check if within maze bounds
            if (node_position[0] > (len(maze) - 1) or 
                node_position[0] < 0 or 
                node_position[1] > (len(maze[0]) - 1) or 
                node_position[1] < 0):
                continue

            # Check if walkable (0 means walkable)
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            # Check if neighbor is in the closed list
            if node_position in closed_list:
                continue

            # Create a new node for the neighbor
            neighbor_node = Node(current_node, node_position)

            # Calculate g, h, and f values
            neighbor_node.g = current_node.g + 1 # Assuming cost of 1 per step
            # Use Manhattan distance for heuristic
            neighbor_node.h = abs(neighbor_node.position[0] - end_node.position[0]) + \
                              abs(neighbor_node.position[1] - end_node.position[1])
            neighbor_node.f = neighbor_node.g + neighbor_node.h

            # Check if neighbor is already in the open list with a higher f value
            for open_node in open_list:
                if neighbor_node == open_node and neighbor_node.g > open_node.g:
                    break
            else:
                # Add the neighbor to the open list
                heapq.heappush(open_list, neighbor_node)

    return None # No path found

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a python program to find the sum of n natural numbers.

number = int(input("Enter an integer: "))
sum = 0
for i in range(1, number + 1):
    sum+= i
print(f"The sum  of {number} natural number is {sum}.")

Q.2) Write a python program for Travelling Salesman Problem.
from itertools import permutations

def calculate_path_cost(graph, path):
    """
    Calculate the total cost of a given path in the graph.
    """
    cost = 0
    for i in range(len(path) - 1):
        cost += graph[path[i]][path[i + 1]]
    cost += graph[path[-1]][path[0]]  # Return to the starting city
    return cost

def TSP(graph):
   #  Find the shortest path that visits every city exactly once and returns to the starting city.
    num_cities = len(graph)

    # Generate all possible paths (permutations of cities)
    cities = list(range(num_cities))
    min_cost = float('inf')
    best_path = None
    
    for perm in permutations(cities):
        current_cost = calculate_path_cost(graph, perm)
        if current_cost < min_cost:
            min_cost = current_cost
            best_path = perm
    
    return best_path, min_cost

if __name__ == "__main__":
    # Distance matrix for 4 cities
    distance_matrix = [[0, 10, 15, 20],  [10, 0, 35, 25],
     			[15, 35, 0, 30], [20, 25, 30, 0]]    
    # Find and print the shortest path and its cost
    path, cost = TSP(distance_matrix)
    print("Optimal path:", path)
    print("Minimum cost:", cost)

--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to make a simple calculator

op = input("Enter operation (+, -, *, /): ")
x= float(input("Enter number1:"))
y= float(input("Enter number2:"))
if op == '+': print(x + y)
elif op == '-': print(x - y)
elif op == '*': print(x * y)
elif op == '/': print(x / y if y != 0 else "Cannot divide by zero")
else: print("Invalid operation")

Q.2) Write a python program to implement A* algorithm.
from heapq import heappush, heappop
from typing import Callable, Any, Dict, List, Tuple, Optional

def a_star(
    start: Any,
    is_goal: Callable[[Any], bool],
    neighbors: Callable[[Any], List[Any]],
    cost: Callable[[Any, Any], float],           # g(n) part - cost between two nodes
    heuristic: Callable[[Any], float],           # h(n) - estimated cost to goal
) -> Tuple[Optional[List[Any]], float]:
    """
    A* search algorithm
    Returns: (path, total_cost) or (None, inf) if no path found
    """
    # Priority queue: (f = g + h, g, node, came_from_key)
    open_set = []
    heappush(open_set, (0 + heuristic(start), 0, start, None))

    # Best known g-score
    g_score: Dict[Any, float] = {start: 0}
    # For path reconstruction
    came_from: Dict[Any, Any] = {}

    while open_set:
        _, g, current, _ = heappop(open_set)

        if is_goal(current):
            # Reconstruct path
            path = []
            while current is not None:
                path.append(current)
                current = came_from.get(current)
            path.reverse()
            return path, g

        for next_node in neighbors(current):
            tentative_g = g + cost(current, next_node)

            if tentative_g < g_score.get(next_node, float('inf')):
                came_from[next_node] = current
                g_score[next_node] = tentative_g
                f = tentative_g + heuristic(next_node)
                heappush(open_set, (f, tentative_g, next_node, current))

    return None, float('inf')
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to check whether given no is Positive, Negative or zero.

num = float(input("Enter a number: "))
if num > 0:
   print("Positive number")
elif num == 0:
   print("Zero")
else:
   print("Negative number")

Q.2) Write a python program to implement Tower of Hanoi.
def tower_of_hanoi(n, src, aux, dest):
    if n == 1:
        print(f"Move disk 1 from rod {src} to rod {dest}")
        return
    tower_of_hanoi(n - 1, src, dest, aux)
    print(f"Move disk {n} from rod {src} to rod {dest}")
    tower_of_hanoi(n - 1, aux, src, dest)

if __name__ == "__main__":
    n = int(input("Enter the number of disks: "))
    tower_of_hanoi(n, 'A', 'B', 'C')
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a python program to print multiplication table of given Number.

# Accept a number from the user
number = int(input("Enter a number: "))

# Print the multiplication table for the given number
for i in range(1, 11):
    print(f"{number} x {i} = {number * i}")	

Q.2) Write a python program implement Breadth First Search (BFS) algorithm.
visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a program to find the Largest number amongst three integer Numbers.
# Accept three integer numbers from the user
num1 = int(input("Enter the first integer number: "))
num2 = int(input("Enter the second integer number: "))
num3 = int(input("Enter the third integer number: "))

# Find the largest number
if num1 >= num2 and num1 >= num3:
    largest = num1
elif num2 >= num1 and num2 >= num3:
    largest = num2
else:
    largest = num3

# Print the largest number
print(f"The largest number among {num1}, {num2}, and {num3} is {largest}.")

Q.2) Write a python program to implement Depth First Search (DFS) algorithm.
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.
def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node,end='  ')
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)


print("Following is the Depth-First Search")
dfs(visited, graph, '5') # function calling

--------------------------------------------------------------------------------------------------------------------------------------
Q.1) Write a Python program to display calendar of the given month and year.

# Get the month and year from the user
year = int(input("Enter year (e.g., 2024): "))
month = int(input("Enter month (1-12): "))
# Display the calendar for the specified month and year
print(calendar.month(year, month))	

Q.2) Write a python program to implement Simple Chatbot.
import nltk
from nltk.chat.util import Chat, reflections

# Define pairs of patterns and responses
pairs = [
    ["hi|hello|hey", ["Hello!", "Hey there!", "Hi!"]],
    ["how are you?", ["I'm good, thanks!", "Doing well, thank you!", "I'm fine, how about you?"]],
    ["what's your name?", ["I'm a chatbot.", "You can call me Chatbot.", "I'm Chatbot!"]],
    ["quit|exit|bye", ["Goodbye!", "Bye!", "See you later!"]],
]

# Create a chatbot
chatbot = Chat(pairs, reflections)

# Start conversation
print("Welcome to the chatbot!")
print("Type 'quit' to exit.")

while True:
    user_input = input("You: ")
    response = chatbot.respond(user_input)
    print("Chatbot:", response)
    if user_input.lower() in ["quit", "exit", "bye"]:
        Break
--------------------------------------------------------------------------------------------------------------------------------------

Q.1) Write a Python program to count the digits in a number.
num = input("Enter a number: ")

# Handle the case when user enters nothing or just spaces
if num.strip() == "":
    print("No number was entered.")
else:
    try:
        # Convert to integer (will raise error if not a valid number)
        number = int(num)
        
        # Count digits (works with negative numbers too)
        digit_count = len(str(abs(number)))
        
        if number == 0:
            digit_count = 1
            
        print(f"The number {number} has {digit_count} digit(s).")
        
    except ValueError:
        print("Error: Please enter a valid integer number.")

Q.2) Write a python program to solve 8-Puzzle problem.
import heapq

class Node:
    """A node class for A* pathfinding."""
    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position
        self.g = 0 # Cost from start
        self.h = 0 # Heuristic cost to goal
        self.f = 0 # Total cost (g + h)

    def __eq__(self, other):
        return self.position == other.position

    # For use with the priority queue (heapq)
    def __lt__(self, other):
        return self.f < other.f

def astar(maze, start, end):
    """Finds the shortest path in a maze using A*."""
    # Create start and end nodes
    start_node = Node(None, start)
    end_node = Node(None, end)

    # Initialize open and closed lists
    open_list = []
    closed_list = set()

    # Add the start node to the open list
    heapq.heappush(open_list, start_node)

    # Loop until the open list is empty
    while open_list:
        # Get the current node (node with the lowest f cost)
        current_node = heapq.heappop(open_list)
        closed_list.add(current_node.position)

        # Found the goal
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current.position)
                current = current.parent
            return path[::-1] # Return reversed path

        # Explore neighbors (up, down, left, right)
        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        for new_position in neighbors:
            # Get neighbor node position
            node_position = (current_node.position[0] + new_position[0], 
                             current_node.position[1] + new_position[1])

            # Check if within maze bounds
            if (node_position[0] > (len(maze) - 1) or 
                node_position[0] < 0 or 
                node_position[1] > (len(maze[0]) - 1) or 
                node_position[1] < 0):
                continue

            # Check if walkable (0 means walkable)
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            # Check if neighbor is in the closed list
            if node_position in closed_list:
                continue

            # Create a new node for the neighbor
            neighbor_node = Node(current_node, node_position)

            # Calculate g, h, and f values
            neighbor_node.g = current_node.g + 1 # Assuming cost of 1 per step
            # Use Manhattan distance for heuristic
            neighbor_node.h = abs(neighbor_node.position[0] - end_node.position[0]) + \
                              abs(neighbor_node.position[1] - end_node.position[1])
            neighbor_node.f = neighbor_node.g + neighbor_node.h

            # Check if neighbor is already in the open list with a higher f value
            for open_node in open_list:
                if neighbor_node == open_node and neighbor_node.g > open_node.g:
                    break
            else:
                # Add the neighbor to the open list
                heapq.heappush(open_list, neighbor_node)

    return None # No path found
